"""Snakefile used by Snakemake."""
import copy
import inspect
import os
import re
import sys
from collections import defaultdict

import snakemake
from snakemake.logging import logger

from sparv import util
from sparv.core import config as sparv_config
from sparv.core import paths, registry
from sparv.util.classes import *

# All output annotations available, used for printing a list
all_annotations = {}

# All named targets available, used in list_targets
named_targets = []
export_targets = []
install_targets = []
model_targets = []

# Outputs from all installers, used in install_annotated_corpus
install_outputs = defaultdict(list)

# List which will contain all source files
source_files = []

# Remove Snakemake's default log handler
if config.get("run_by_sparv") and logger.log_handler and logger.log_handler[0] == logger.text_handler:
    logger.log_handler = []


def get_source_path() -> str:
    """Get path to source files."""
    return sparv_config.get("source_dir", paths.source_dir)


def get_annotation_path(annotation, data=False, common=False):
    """Construct a path to an annotation file given a doc and annotation."""
    elem, attr = util.split_annotation(annotation)

    if data or common:
        path = elem
    else:
        if not attr:
            attr = util.SPAN_ANNOTATION
        path = os.path.join(elem, attr)
    if not common:
        path = "{doc}/" + path
    return path


def get_source_files() -> List[str]:
    """Get list of all available source files"""
    global source_files
    if not source_files:
        source_files = [f[1][0] for f in snakemake.utils.listfiles(
            os.path.join(get_source_path(), "{file}." + sparv_config.get("source_type", "xml")))]
    return source_files


def make_rule(module_name, f_name, annotator_info) -> None:
    """Build Snakemake rules."""
    # Build input, output and parameter list
    if config.get("debug"):
        print()
        print("{}{}:{} {}".format(util.Color.BOLD, module_name.upper(), util.Color.RESET, f_name))
        print()
    inputs = []
    outputs = []
    parameters = {}
    docs = []  # List of parameters referring to Document
    doc_annotations = []  # List of parameters containing the {doc} wildcard
    wildcard_annotations = []  # List of parameters containing other wildcards
    target_name = module_name + ":" + f_name

    annotator = annotator_info["type"] is registry.Annotator.annotator
    importer = annotator_info["type"] is registry.Annotator.importer
    exporter = annotator_info["type"] is registry.Annotator.exporter
    installer = annotator_info["type"] is registry.Annotator.installer
    modelbuilder = annotator_info["type"] is registry.Annotator.modelbuilder
    description = annotator_info["description"]
    source_type = annotator_info["source_type"]
    import_outputs = annotator_info["outputs"]

    # Skip any annotator that is not available for the selected corpus language
    if annotator_info["language"] and sparv_config.get("language") not in annotator_info["language"]:
        return

    if importer:
        inputs.append(os.path.join(get_source_path(), "{doc}." + source_type))
        if source_type == sparv_config.get("source_type", "xml"):
            # Exports always generate corpus text file
            outputs.append(os.path.join(paths.annotation_dir, "{doc}", util.TEXT_FILE))
            # If importer guarantees other outputs, add them to outputs list
            if import_outputs:
                if isinstance(import_outputs, Config):
                    import_outputs = sparv_config.get(import_outputs, import_outputs.default)
                annotations_ = set()
                for annotation in import_outputs:
                    annotations_.add(annotation)
                    annotations_.add(util.split_annotation(annotation)[0])
                for element in annotations_:
                    outputs.append(os.path.join(paths.annotation_dir, get_annotation_path(element)))

    params = inspect.signature(annotator_info["function"]).parameters

    def escape_wildcards(s):
        """Escape all wildcards other than {doc}."""
        return re.sub(r"(?!{doc})({[^}]+})", r"{\1}", s)

    # Go though function parameters and handle based on type
    for param_name, param in params.items():
        # Output
        if isinstance(param.default, Output):
            param_value = registry.expand_variables(param.default)
            ann_path = get_annotation_path(param_value, data=param.default.data, common=param.default.common)
            if param.default.all_docs:
                outputs.extend(expand(escape_wildcards(os.path.join(paths.annotation_dir, ann_path)),
                                      doc=get_source_files()))
            elif param.default.common:
                outputs.append(os.path.join(paths.annotation_dir, ann_path))
                if installer:
                    install_outputs[target_name].append(os.path.join(paths.annotation_dir, ann_path))
            else:
                outputs.append(get_annotation_path(param_value, data=param.default.data))
            parameters[param_name] = param_value
            if "{" in param_value:
                wildcard_annotations.append(param_name)
            all_annotations.setdefault(module_name, {}).setdefault(f_name, {"description": description,
                                                                            "annotations": []})
            all_annotations[module_name][f_name]["annotations"].append((param.default, param.default.description))
        # ModelOutput
        elif isinstance(param.default, ModelOutput):
            param_value = registry.expand_variables(param.default)
            outputs.append(paths.get_model_path(param_value))
        # Annotation
        elif registry.dig(Annotation, param.default):
            param_value = registry.expand_variables(param.default)
            ann_path = get_annotation_path(param_value, data=param.default.data, common=param.default.common)
            if exporter or installer or param.default.all_docs:
                if param.default.all_docs:
                    inputs.extend(expand(escape_wildcards(os.path.join(paths.annotation_dir, ann_path)),
                                         doc=get_source_files()))
                else:
                    inputs.append(os.path.join(paths.annotation_dir, ann_path))
            elif param.default.common:
                inputs.append(os.path.join(paths.annotation_dir, ann_path))
            else:
                inputs.append(ann_path)

                # Add @text as requirement for all rules with non-data Annotation dependencies
                text_file = get_annotation_path(util.TEXT_FILE, data=True)
                if not param.default.data and not text_file in inputs:
                    inputs.append(text_file)
            parameters[param_name] = param_value
            if "{" in param_value:
                wildcard_annotations.append(param_name)
        # ExportAnnotations
        elif param.default == ExportAnnotations or isinstance(param.default, ExportAnnotations):
            parameters[param_name] = []
            export_annotations = sparv_config.get("annotations", [])
            for annotation in export_annotations:
                annotation, _, new_name = annotation.partition(" as ")
                param_value = registry.expand_variables(annotation)
                if param.default.is_input:
                    inputs.append(os.path.join(paths.annotation_dir, get_annotation_path(param_value)))
                if new_name:
                    param_value = " as ".join((param_value, new_name))
                parameters[param_name].append(param_value)
        # Corpus
        elif param.default == Corpus or isinstance(param.default, Corpus):
            parameters[param_name] = sparv_config.get("id")
        # Language
        elif param.default == Language or isinstance(param.default, Language):
            parameters[param_name] = sparv_config.get("language")
        # Document
        elif param.default == Document or isinstance(param.default, Document):
            docs.append(param_name)
        # AllDocuments (all source documents)
        elif registry.dig(AllDocuments, param.default):
            parameters[param_name] = get_source_files()
        # Model
        elif registry.dig(Model, param.default):
            if param.default is not None:
                if isinstance(param.default, Model):
                    model = paths.get_model_path(registry.expand_variables(param.default))
                    inputs.append(model)
                    parameters[param_name] = model
                elif isinstance(param.default, (list, tuple)):
                    parameters[param_name] = []
                    for model in param.default:
                        model = paths.get_model_path(registry.expand_variables(model))
                        inputs.append(model)
                        parameters[param_name].append(model)
        # Binary
        elif isinstance(param.default, Binary):
            binary = paths.get_bin_path(registry.expand_variables(param.default))
            inputs.append(binary)
            parameters[param_name] = binary
        # Source
        elif param.default == Source or isinstance(param.default, Source):
            parameters[param_name] = get_source_path()
        # Export
        elif param.default == Export or isinstance(param.default, Export):
            if param.default.absolute_path:
                parameters[param_name] = registry.expand_variables(param.default)
            else:
                parameters[param_name] = os.path.join(paths.export_dir, registry.expand_variables(param.default))
            outputs.append(parameters[param_name])
            if "{doc}" in parameters[param_name]:
                doc_annotations.append(param_name)
            param_value = registry.expand_variables(param.default)
            if "{" in param_value:
                wildcard_annotations.append(param_name)
        # ExportInput
        elif isinstance(param.default, ExportInput):
            if param.default.absolute_path:
                parameters[param_name] = registry.expand_variables(param.default)
            else:
                parameters[param_name] = os.path.join(paths.export_dir, registry.expand_variables(param.default))
            if param.default.all_docs:
                inputs.extend(expand(escape_wildcards(parameters[param_name]), doc=get_source_files()))
            else:
                inputs.append(parameters[param_name])
            if "{" in parameters[param_name]:
                wildcard_annotations.append(param_name)
        # Config
        elif isinstance(param.default, Config):
            parameters[param_name] = sparv_config.get(param.default, param.default.default)
        # Everything else with a default value
        elif param.default is not None:
            parameters[param_name] = param.default

    if config.get("debug"):
        print("    " + util.Color.BOLD + "INPUTS" + util.Color.RESET)
        for i in inputs:
            print("        {}".format(i))
        print()
        print("    " + util.Color.BOLD + "OUTPUTS" + util.Color.RESET)
        for o in outputs:
            print("        {}".format(o))
        print()
        print("    " + util.Color.BOLD + "PARAMETERS" + util.Color.RESET)
        for p in parameters:
            print("        {} = {!r}".format(p, parameters[p]))
        print()
        print()

    def get_doc_value(wildcards):
        """Extract the {doc} part from full annotation path."""
        doc = None
        if hasattr(wildcards, "doc"):
            if annotator:
                doc = wildcards.doc[len(paths.annotation_dir) + 1:]
            else:
                doc = wildcards.doc
        return doc

    def get_parameters(wildcards):
        """Extend function parameters with doc names and replace wildcards."""
        doc = get_doc_value(wildcards)
        # We need to make a copy of the parameters, since the rule might be used for multiple documents
        _parameters = copy.deepcopy(parameters)
        _parameters.update({name: doc for name in docs})

        # Replace {doc} wildcard in parameters
        for name in doc_annotations:
            _parameters[name] = _parameters[name].replace("{doc}", doc)

        # Replace wildcards (other than {doc}) in parameters
        for name in wildcard_annotations:
            wcs = re.finditer(r"(?!{doc}){([^}]+)}", _parameters[name])
            for wc in wcs:
                _parameters[name] = _parameters[name].replace(wc.group(), wildcards.get(wc.group(1)))
        return _parameters

    rule:
        message:
            "{}:{}".format(module_name, f_name)
        input:
            inputs
        output:
            outputs
        params:
            module_name = module_name,
            f_name = f_name,
            parameters = get_parameters,
            log = config.get("log")
        script:
            "run_snake.py"
            # We don't use "run:" since the whole Snakefile would have to be reloaded for every single job, due to how
            # Snakemake creates processes for run-jobs.

    # Create rule to run this annotation on all input files, but skip rules containing wildcards
    if not any(re.search(r"(?!{doc}){[^}]+}", o) for o in outputs):
        if exporter:
            export_targets.append((target_name, description))
        elif installer:
            install_targets.append((target_name, description))
        elif modelbuilder:
            model_targets.append((target_name, description))
        else:
            named_targets.append((target_name, description))
        @workflow.rule(name=target_name)
        @workflow.input(expand([os.path.join(paths.annotation_dir, o)
                                if not (o.startswith(paths.annotation_dir) or o.startswith(paths.export_dir))
                                else o
                                for o in outputs], doc=config.get("file") or get_source_files()))
        @workflow.run
        def __rule__(*_args, **_kwargs):
            pass


rule empty:
    shell:
        "echo"

# Find local corpus config
corpus_config_file = os.path.join(os.getcwd(), paths.config_file)
if not os.path.isfile(corpus_config_file):
    print("No corpus config file found.")
    sys.exit(1)

# Read config file(s)
sparv_config.load_config(corpus_config_file)

# Find and load Sparv modules
registry.find_modules(paths.sparv_path)

# Add classes collected from modules to config
registry.annotation_classes["config_classes"] = sparv_config.config.get("classes", {})

# Create rules for all available annotation functions
for module_name in registry.annotators:
    for f_name in registry.annotators[module_name]:
        annotator = registry.annotators[module_name][f_name]
        make_rule(module_name, f_name, annotator)

# Rule to list all config options and their current values
rule config:
    run:
        import yaml
        class MyDumper(yaml.Dumper):
            """Customized YAML dumper that indents lists."""

            def increase_indent(self, flow=False, indentless=False):
                """Force indentation."""
                return super(MyDumper, self).increase_indent(flow, False)

        yaml_str = yaml.dump(sparv_config.config, default_flow_style=False, Dumper=MyDumper, indent=4)
        # Colorize keys for easier reading
        yaml_str = re.sub(r"^(\s*[\S]+):", util.Color.BLUE + r"\1" + util.Color.RESET + ":", yaml_str,
                          flags=re.MULTILINE)
        print(yaml_str)

rule annotations:
    run:
        max_len = max(len(a[0]) for m in all_annotations for f in all_annotations[m]
                      for a in all_annotations[m][f]["annotations"]) + 8
        print()
        print("Available modules, annotators and annotations")
        print("=============================================\n")
        for module_name in sorted(all_annotations):
            print(util.Color.BOLD + "{}".format(module_name.upper()) + util.Color.RESET)
            for f_name in sorted(all_annotations[module_name]):
                print("      {}{}{}".format(util.Color.UNDERLINE, f_name, util.Color.RESET))
                f_desc = all_annotations[module_name][f_name]["description"]
                if f_desc:
                    print("      {}".format(f_desc))
                print()
                f_anns = all_annotations[module_name][f_name]["annotations"]
                for f_ann in sorted(f_anns):
                    print("        • {:{width}}{}".format(f_ann[0], f_ann[1] or "", width=max_len))
                    if f_ann[0].cls:
                        print(util.Color.ITALIC + "          <{}>".format(f_ann[0].cls) + util.Color.RESET)
                print()
            print("\n")

        max_len = max(len(cls) for cls in registry.annotation_classes["module_classes"]) + 8

        print("Available classes")
        print("=================\n")
        print(util.Color.BOLD + "    Classes defined by pipeline modules"+ util.Color.RESET)
        print("        {}{:{}}    {}{}".format(util.Color.ITALIC, "Class", max_len, "Annotation", util.Color.RESET))
        for cls, anns in registry.annotation_classes["module_classes"].items():
            print("        {:{}}    {}".format(cls, max_len, anns[0]))
            if len(anns) > 1:
                for ann in anns[1:]:
                    print("        {:{}}    {}".format("", max_len, ann))

        if registry.annotation_classes["config_classes"]:
            print()
            print(util.Color.BOLD + "    Classes from config" + util.Color.RESET)
            print("        {}{:{}}    {}{}".format(util.Color.ITALIC, "Class", max_len, "Annotation", util.Color.RESET))
            for cls, ann in registry.annotation_classes["config_classes"].items():
                print("        {:{}}    {}".format(cls, max_len, ann))

rule list_targets:
    run:
        max_len = max(len(t[0]) for t in named_targets + export_targets) + 4
        print()
        print("Available targets")
        print("=================\n")
        print("    EXPORTS")
        for target, desc in sorted(export_targets):
            print("        {:{}}    {}".format(target, max_len, desc))
        print()
        print("    INSTALLERS")
        for target, desc in sorted(install_targets):
            print("        {:{}}    {}".format(target, max_len, desc))
        print()
        print("    ANNOTATIONS")
        for target, desc in sorted(named_targets):
            print("        {:{}}    {}".format(target, max_len, desc))
        print()
        print("    MODEL BUILDERS")
        for target, desc in sorted(model_targets):
            print("        {:{}}    {}".format(target, max_len, desc))

rule files:
    # List all input files
    run:
        print("Available input files:\n")
        print(", ".join(get_source_files()))

rule clean:
    # Remove annotations dir
    run:
        # Only run if corpus config is found in same dir
        if corpus_config_file is None:
            print("No corpus config found. Not removing anything.")
        else:
            import shutil
            if config.get("export"):
                to_remove = paths.export_dir
                assert paths.export_dir, "Export dir name not configured."
            else:
                to_remove = paths.annotation_dir
                assert paths.annotation_dir, "Annotations dir name not configured."

            full_path = os.path.join(os.getcwd(), to_remove)
            if os.path.isdir(full_path):
                shutil.rmtree(full_path)
                print(to_remove, "directory removed")
            else:
                print("Nothing to remove")


# Collect files to be created for all installations listed in config.install
install_inputs = []
for installation in sparv_config.config.get("install"):
    install_inputs.extend(install_outputs[installation])

rule install_annotated_corpus:
    input:
        install_inputs
